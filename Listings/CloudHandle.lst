C51 COMPILER V9.59.0.0   CLOUDHANDLE                                                       04/13/2020 15:54:55 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLOUDHANDLE
OBJECT MODULE PLACED IN .\Objects\CloudHandle.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\AlibabaCloud\CloudHandle.c OMF2 OPTIMIZE(9,SPEED) BROWSE MODP2 INCD
                    -IR(.\Code\Basic\def;.\Code\Basic\delay;.\Code\Basic\init;.\Code\Basic\uart;.\Code\Sensor\DS18B20;.\Code\Sensor\LCD1602;.
                    -\Code\AlibabaCloud) DEBUG PRINT(.\Listings\CloudHandle.lst) OBJECT(.\Objects\CloudHandle.obj)

line level    source

   1          #include "CloudHandle.h"
   2          //------------------------------------------------------------------------------------------------//
   3          //Cloud任务#状态指示器
   4          xdata CloudActST CloudAct;
   5          //------------------------------------------------------------------------------------------------//
   6          //各函数缓冲区
   7          static xdata uchar CloudReceiveBuffer[CloudReceiveBufferSize]; //串口数据处理缓冲区-CloudReceive函数
   8          static xdata ushort CloudReceiveIdx;                           //串口数据处理缓冲区下标-CloudReceive函数
   9          static xdata uchar CloudSendBuffer[CloudSendBufferSize];       //生成AT指令缓冲区-CloudSend函数
  10          static xdata ushort CloudSendIdx;                              //生成AT指令缓冲区下标-CloudSend函数
  11          static xdata uchar CloudSendData[CloudSendDataSize];           //上报设备属性计算缓冲区-CloudReport函数
  12          static xdata ushort CloudSendDataIdx;                          //记录缓冲区写入大小-CloudReport函数
  13          //------------------------------------------------------------------------------------------------//
  14          static void CloudReceive(void);       //接收串口缓冲区数据
  15          static bool CloudSend(uchar op);      //发送命令到串口
  16          static bool CloudReport(uchar Code);  //设备上报
  17          static void CloudHandleReceive(void); //处理CloudReceive收到的一条WiFi信息
  18          //------------------------------------------------------------------------------------------------//
  19          void CloudLoop(void) //Cloud主循环
  20          {
  21   1          CloudReceive(); //##接收并处理串口缓冲区数据
  22   1          //注册任务
  23   1          if (CloudAct.NeedReadDS18B20 == false && CloudAct.SysTime - CloudAct.NeedReadDS18B20_Ms >= DS18B20Need
             -ReadMs && DS18B20ConvertTemperature() == EXIT_SUCCESS) //需要读取DS18B20温度值,且温度转换指令成功
  24   1              CloudAct.NeedReadDS18B20 = true, CloudAct.NeedReadDS18B20_Ms = CloudAct.SysTime;                  
             -                                                       //等待读取温度值
  25   1                                                                                                                
             -                                                       //待执行任务
  26   1          if (CloudAct.NeedReport_WaterTemperatureLow == true && CloudReport(1) == 0)
  27   1              CloudAct.NeedReport_WaterTemperatureLow = false;
  28   1          if (CloudAct.NeedReport_WaterTemperatureHigh == true && CloudReport(2) == 0)
  29   1              CloudAct.NeedReport_WaterTemperatureHigh = false;
  30   1          if (CloudAct.NeedReport == true && CloudReport(0) == 0)
  31   1              CloudAct.NeedReport = false;
  32   1      
  33   1          if (CloudAct.NeedReadDS18B20 == true && CloudAct.SysTime - CloudAct.NeedReadDS18B20_Ms >= DS18B20Conve
             -rtTMaxTime[DS18B20ST.ResolutionMode] && DS18B20GetTemperature() == EXIT_SUCCESS) //成功执行读取温度值
  34   1              CloudAct.NeedReadDS18B20 = false, CloudAct.NeedReadDS18B20_Ms = CloudAct.SysTime;
  35   1      }
  36          void CloudInit(void) //初始化Cloud
  37          {
  38   1          xdata ulong TempT;
  39   1          memset(&CloudAct, 0, sizeof(CloudAct));                //清零任务指示器
  40   1          CloudSendDataIdx = CloudSendIdx = CloudReceiveIdx = 0; //各缓冲区下标清零
  41   1      //------------------------------------------------//
  42   1      T0:
  43   1          CloudAct.Cmd = AT_REBOOT; //连接路由器
  44   1          CloudSend(2);
  45   1          TempT = CloudAct.SysTime; //记录命令发送时间
  46   1          while (CloudAct.NeedAns == true)
  47   1          {
  48   2              CloudReceive();
  49   2              if (CloudAct.SysTime - TempT >= 2000) //2000ms没有完成命令
C51 COMPILER V9.59.0.0   CLOUDHANDLE                                                       04/13/2020 15:54:55 PAGE 2   

  50   2              {
  51   3                              CloudAct.NeedAns=false;
  52   3                              goto T0;//重发指令
  53   3                      }
  54   2          }
  55   1      #if LOGRANK_UART1 >= 2
  56   1          printf("LOG#:CloudInit-Reboot ok\r\n"); //日志记录模块重启完毕
  57   1      #endif
  58   1      //------------------------------------------------//
  59   1      T1:
  60   1          CloudAct.Cmd = AT_WJAP; //连接路由器
  61   1          CloudSend(0);
  62   1          TempT = CloudAct.SysTime; //记录命令发送时间
  63   1          while (CloudAct.NeedAns == true)
  64   1          {
  65   2              CloudReceive();
  66   2              if (CloudAct.SysTime - TempT >= 2000) //2000ms没有完成命令
  67   2              {
  68   3                              CloudAct.NeedAns=false;
  69   3                              goto T1;//重发指令
  70   3                      }       
  71   2          }
  72   1      #if LOGRANK_UART1 >= 2
  73   1          printf("LOG#:CloudInit-WiFiConect ok\r\n"); //日志记录目标WiFi已连接
  74   1      #endif
  75   1      //------------------------------------------------//
  76   1      T2:
  77   1          CloudAct.Cmd = AT_MQTTAUTH; //设置MQTT用户名密码
  78   1          CloudSend(0);
  79   1          TempT = CloudAct.SysTime; //记录命令发送时间
  80   1          while (CloudAct.NeedAns == true)
  81   1          {
  82   2              CloudReceive();
  83   2              if (CloudAct.SysTime - TempT >= 1500) //1500ms没有完成命令
  84   2              {
  85   3                              CloudAct.NeedAns=false;
  86   3                              goto T2;//重发指令
  87   3                      }       
  88   2          }
  89   1      #if LOGRANK_UART1 >= 2
  90   1          printf("LOG#:CloudInit-MQTT_UserSet ok\r\n"); //日志记录MQTT用户名和密码设置完毕
  91   1      #endif
  92   1      //------------------------------------------------//
  93   1      T3:
  94   1          CloudAct.Cmd = AT_MQTTSOCK; //设置MQTT主机和端口
  95   1          CloudSend(0);
  96   1          TempT = CloudAct.SysTime; //记录命令发送时间
  97   1          while (CloudAct.NeedAns == true)
  98   1          {
  99   2              CloudReceive();
 100   2              if (CloudAct.SysTime - TempT >= 1500) //1500ms没有完成命令
 101   2              {
 102   3                              CloudAct.NeedAns=false;
 103   3                              goto T3;//重发指令
 104   3                      }
 105   2          }
 106   1      #if LOGRANK_UART1 >= 2
 107   1          printf("LOG#:CloudInit-MQTT_HostSet ok\r\n"); //日志记录MQTT主机和端口设置完毕
 108   1      #endif
 109   1      //------------------------------------------------//
 110   1      T4:
 111   1          CloudAct.Cmd = AT_MQTTCID; //设置MQTT客户端ID
C51 COMPILER V9.59.0.0   CLOUDHANDLE                                                       04/13/2020 15:54:55 PAGE 3   

 112   1          CloudSend(0);
 113   1          TempT = CloudAct.SysTime; //记录命令发送时间
 114   1          while (CloudAct.NeedAns == true)
 115   1          {
 116   2              CloudReceive();
 117   2              if (CloudAct.SysTime - TempT >= 1500) //1500ms没有完成命令
 118   2              {
 119   3                              CloudAct.NeedAns=false;
 120   3                              goto T4;//重发指令
 121   3                      }
 122   2          }
 123   1      #if LOGRANK_UART1 >= 2
 124   1          printf("LOG#:CloudInit-MQTT_ClintIDSet ok\r\n"); //日志记录MQTT客户端ID设置完毕
 125   1      #endif
 126   1      //------------------------------------------------//
 127   1      T5:
 128   1          CloudAct.Cmd = AT_MQTTKEEPALIVE; //设置MQTT心跳周期
 129   1          CloudSend(0);
 130   1          TempT = CloudAct.SysTime; //记录命令发送时间
 131   1          while (CloudAct.NeedAns == true)
 132   1          {
 133   2              CloudReceive();
 134   2              if (CloudAct.SysTime - TempT >= 1500) //1500ms没有完成命令
 135   2              {
 136   3                              CloudAct.NeedAns=false;
 137   3                              goto T5;//重发指令
 138   3                      }
 139   2          }
 140   1      #if LOGRANK_UART1 >= 2
 141   1          printf("LOG#:CloudInit-MQTT_HeartSet ok\r\n"); //日志记录MQTT心跳时间设置完毕
 142   1      #endif
 143   1      //------------------------------------------------//
 144   1      T6:
 145   1          CloudAct.Cmd = AT_MQTTRECONN; //设置MQTT是否自动重连
 146   1          CloudSend(0);
 147   1          TempT = CloudAct.SysTime; //记录命令发送时间
 148   1          while (CloudAct.NeedAns == true)
 149   1          {
 150   2              CloudReceive();
 151   2              if (CloudAct.SysTime - TempT >= 1500) //1500ms没有完成命令
 152   2              {
 153   3                              CloudAct.NeedAns=false;
 154   3                              goto T6;//重发指令
 155   3                      }
 156   2          }
 157   1      #if LOGRANK_UART1 >= 2
 158   1          printf("LOG#:CloudInit-MQTT_AutoReConect Set ok\r\n"); //日志记录MQTT自动重连设置完毕
 159   1      #endif
 160   1      //------------------------------------------------//
 161   1      T7:
 162   1          CloudAct.Cmd = AT_MQTTAUTOSTART; //设置MQTT是否上电自动开启
 163   1          CloudSend(0);
 164   1          TempT = CloudAct.SysTime; //记录命令发送时间
 165   1          while (CloudAct.NeedAns == true)
 166   1          {
 167   2              CloudReceive();
 168   2              if (CloudAct.SysTime - TempT >= 1500) //1500ms没有完成命令
 169   2              {
 170   3                              CloudAct.NeedAns=false;
 171   3                              goto T7;//重发指令
 172   3                      }
 173   2          }
C51 COMPILER V9.59.0.0   CLOUDHANDLE                                                       04/13/2020 15:54:55 PAGE 4   

 174   1      #if LOGRANK_UART1 >= 2
 175   1          printf("LOG#:CloudInit-MQTT_AutoStartSet ok\r\n"); //日志记录MQTT上电自动开启设置完毕
 176   1      #endif
 177   1      //------------------------------------------------//
 178   1      T8:
 179   1          CloudAct.Cmd = AT_MQTTSTART; //开启MQTT
 180   1          CloudSend(2);
 181   1          TempT = CloudAct.SysTime; //记录命令发送时间
 182   1          while (CloudAct.NeedAns == true)
 183   1          {
 184   2              CloudReceive();
 185   2              if (CloudAct.SysTime - TempT >= 1500) //1500ms没有完成命令
 186   2              {
 187   3                              CloudAct.NeedAns=false;
 188   3                              goto T8;//重发指令
 189   3                      }
 190   2          }
 191   1      #if LOGRANK_UART1 >= 2
 192   1          printf("LOG#:CloudInit-MQTT_Start ok\r\n"); //日志记录MQTT开启成功
 193   1      #endif
 194   1      //------------------------------------------------//
 195   1      T9:
 196   1          CloudAct.Cmd = AT_MQTTPUB; //设置MQTT发布-默认为参数发布PubCode=0
 197   1          CloudAct.PubCode_t = 0;
 198   1          CloudSend(0);
 199   1          TempT = CloudAct.SysTime; //记录命令发送时间
 200   1          while (CloudAct.NeedAns == true)
 201   1          {
 202   2              CloudReceive();
 203   2              if (CloudAct.SysTime - TempT >= 1500) //1500ms没有完成命令
 204   2              {
 205   3                              CloudAct.NeedAns=false;
 206   3                              goto T9;//重发指令
 207   3                      }
 208   2          }
 209   1          //------------------------------------------------//
 210   1      #if LOGRANK_UART1 >= 2
 211   1          printf("LOG#:CloudInit ok\r\n"); //日志记录Cloud初始化完毕
 212   1      #endif
 213   1      }
 214          //------------------------------------------------------------------------------------------------//
 215          static void CloudReceive(void) //接收串口缓冲区数据
 216          {
 217   1          static uchar State = 0; //接收状态
 218   1          ushort idx1 = uart4_idx1, idx2 = uart4_idx2;
 219   1          while (idx1 != idx2)
 220   1          {
 221   2              switch (State)
 222   2              {
 223   3              case 0: //等待中
 224   3                  if (uart4_buffer[idx1] == 0x0A)
 225   3                      ++State; //等待/r
 226   3                  break;
 227   3              case 1:                             //读取中
 228   3                  if (uart4_buffer[idx1] == 0x0D) //发现\n,结束读取,由CloudHandleReceive函数处理
 229   3                  {
 230   4                      if (CloudReceiveIdx >= 2)                      //命令空隙,回到State=1;
 231   4                      {                                              //###此处决定过滤长度不足2的命令,主要针对MQ
             -TTSEND的>
 232   5                          CloudReceiveBuffer[CloudReceiveIdx++] = 0; //放置字符串末尾,方便处理
 233   5                          CloudHandleReceive();                      //处理收到的信息
 234   5                      }
C51 COMPILER V9.59.0.0   CLOUDHANDLE                                                       04/13/2020 15:54:55 PAGE 5   

 235   4                      State = 0; //开始新的接收
 236   4                      CloudReceiveIdx = 0;
 237   4                      CloudReceiveBuffer[0] = 0;
 238   4                  }
 239   3                  else
 240   3                      CloudReceiveBuffer[CloudReceiveIdx++] = uart4_buffer[idx1];
 241   3              }
 242   2              if (idx1 + 1 == uart4_buffer_size)
 243   2                  idx1 = 0;
 244   2              else
 245   2                  ++idx1;
 246   2              uart4_idx1 = idx1;
 247   2          }
 248   1      }
 249          static bool CloudSend(uchar op) //发送命令到串口
 250          {
 251   1          pdata uchar i = 0;
 252   1          if (CloudAct.NeedAns) //尚有信息未应答
 253   1              return 1;
 254   1          CloudSendIdx = sprintf(CloudSendBuffer, "AT+%s", ATCmd[CloudAct.Cmd]);
 255   1          switch (op)
 256   1          {
 257   2          case 0: //设置参数
 258   2              switch (CloudAct.Cmd)
 259   2              {
 260   3              case AT_MQTTAUTH:
 261   3                  sprintf(CloudSendBuffer + CloudSendIdx, "=%s,%s\r", MQTTUser, MQTTPassword);
 262   3                  break;
 263   3              case AT_MQTTSOCK:
 264   3                  sprintf(CloudSendBuffer + CloudSendIdx, "=%s,%s\r", MQTTHost, MQTTPort);
 265   3                  break;
 266   3              case AT_MQTTCID:
 267   3                  sprintf(CloudSendBuffer + CloudSendIdx, "=%s\r", MQTTClientID);
 268   3                  break;
 269   3              case AT_MQTTKEEPALIVE:
 270   3                  sprintf(CloudSendBuffer + CloudSendIdx, "=%s\r", MQTTHeartBeat);
 271   3                  break;
 272   3              case AT_MQTTRECONN:
 273   3                  sprintf(CloudSendBuffer + CloudSendIdx, "=%s\r", MQTTAutoReConect);
 274   3                  break;
 275   3              case AT_MQTTAUTOSTART:
 276   3                  sprintf(CloudSendBuffer + CloudSendIdx, "=%s\r", MQTTAutoStart);
 277   3                  break;
 278   3              case AT_MQTTSUB:
 279   3                  break;
 280   3              case AT_MQTTPUB:
 281   3                  switch (CloudAct.PubCode_t) //目标Pub
 282   3                  {
 283   4                  case 0: //设备属性上报
 284   4                      sprintf(CloudSendBuffer + CloudSendIdx, "=" PublishSet1 "\r",ProductKey, DeviceName);
 285   4                      break;
 286   4                  case 1: //设备事件上报,Event_1:WaterTemperatureLow
 287   4                      sprintf(CloudSendBuffer + CloudSendIdx, "=" PublishSet2 "\r",ProductKey, DeviceName, Event
             -_1);
 288   4                      break;
 289   4                  case 2: //设备事件上报,Event_2:WaterTemperatureHigh
 290   4                      sprintf(CloudSendBuffer + CloudSendIdx, "=" PublishSet2 "\r",ProductKey, DeviceName, Event
             -_2);
 291   4                      break;
 292   4                  case 200:
 293   4                      sprintf(CloudSendBuffer + CloudSendIdx, "=" PublishSet3 "\r",ProductKey, DeviceName, Servi
             -ce_1);
C51 COMPILER V9.59.0.0   CLOUDHANDLE                                                       04/13/2020 15:54:55 PAGE 6   

 294   4                      break;
 295   4                  }
 296   3                  break;
 297   3              case AT_MQTTSEND:
 298   3                  switch (CloudAct.PubCode) //当前Pub
 299   3                  {
 300   4                  case 0: //设备属性上报
 301   4                      sprintf(CloudSendBuffer + CloudSendIdx, "=%u\r" SendSet1 "\r",
 302   4                              SendSet1Len + CloudSendDataIdx, CloudAct.MQTTSENDid, CloudSendData);
 303   4                      break;
 304   4                  case 1: //设备事件上报,Event_1:WaterTemperatureLow
 305   4                      sprintf(CloudSendBuffer + CloudSendIdx, "=%u\r" SendSet2 "\r",
 306   4                              SendSet2Len + Event_1_Len + CloudSendDataIdx, CloudAct.MQTTSENDid, CloudSendData, 
             -Event_1);
 307   4                      break;
 308   4                  case 2: //设备事件上报,Event_2:WaterTemperatureHigh
 309   4                      sprintf(CloudSendBuffer + CloudSendIdx, "=%u\r" SendSet2 "\r",
 310   4                              SendSet2Len + Event_2_Len + CloudSendDataIdx, CloudAct.MQTTSENDid, CloudSendData, 
             -Event_2);
 311   4                      break;
 312   4                  }
 313   3                  ++CloudAct.MQTTSENDid;
 314   3                  break; //MQTTSEND
 315   3              case AT_WJAP:
 316   3                  sprintf(CloudSendBuffer + CloudSendIdx, "=%s,%s\r", WiFiSSID, WiFiPassword);
 317   3                  break;
 318   3              default:
 319   3                  break;
 320   3              }
 321   2              break;
 322   2          case 3:
 323   2              CloudSendBuffer[CloudSendIdx++] = '='; //查询用户设置的参数
 324   2          case 1:
 325   2              CloudSendBuffer[CloudSendIdx++] = '?'; //查询系统参数
 326   2          case 2:
 327   2              CloudSendBuffer[CloudSendIdx++] = '\r'; //执行命令
 328   2              CloudSendBuffer[CloudSendIdx++] = 0;
 329   2              break;
 330   2          }
 331   1      #if LOGRANK_UART1 >= 2
 332   1          printf("LOG#:CloudSend$%s\r\n", CloudSendBuffer);
 333   1      #endif
 334   1          uart4_sendstr8(CloudSendBuffer, 0);       //发送准备好的命令字符串
 335   1          CloudAct.NeedAns = true;                  //开始等待应答
 336   1          CloudAct.NeedAns_Time = CloudAct.SysTime; //记录发送命令时间
 337   1          return 0;
 338   1      }
 339          static bool CloudReport(uchar Code) //设备上报
 340          {
 341   1          if (CloudAct.NeedAns) //尚有信息未应答
 342   1              return 1;
 343   1          if (Code == 0)
 344   1          {
 345   2              if (CloudAct.PubCode != 0) //Pub未正确切换,切换后返回
 346   2              {
 347   3                  if (CloudAct.PubCode_t != 0) //Pub未开始开始切换到Pub=0
 348   3                  {
 349   4                      CloudAct.Cmd = AT_MQTTPUB;
 350   4                      CloudAct.PubCode_t = 0; //标志已经开始切换
 351   4                      CloudSend(0);           //切换到设备属性Pub
 352   4                  }
 353   3                  return 1;
C51 COMPILER V9.59.0.0   CLOUDHANDLE                                                       04/13/2020 15:54:55 PAGE 7   

 354   3              }
 355   2              CloudSendDataIdx = sprintf(CloudSendData, "\"WaterTemperature\":%.3f",
 356   2                                         (DS18B20ST.TemperatureData) * DS18B20ReTransfrom[DS18B20ST.ResolutionMo
             -de] + (float)DS18B20MinT);
 357   2          }
 358   1          else
 359   1          {
 360   2              if (CloudAct.PubCode != Code) //Pub未正确切换
 361   2              {
 362   3                  xdata ulong TempT;
 363   3              TX:
 364   3                  CloudAct.Cmd = AT_MQTTPUB;
 365   3                  CloudAct.PubCode_t = Code;       //标志已经开始切换
 366   3                  CloudSend(0);                    //切换到设备属性Pub
 367   3                  TempT = CloudAct.SysTime;        //记录命令发送时间
 368   3                  while (CloudAct.PubCode != Code) //等待,直到Pub正确
 369   3                  {
 370   4                      CloudReceive();
 371   4                      if (CloudAct.SysTime - TempT >= 300) //300ms没有完成命令
 372   4                                      {
 373   5                                              CloudAct.NeedAns=false;
 374   5                                              goto TX;//重发指令
 375   5                                      }
 376   4                  }
 377   3              }
 378   2              switch (Code)
 379   2              {
 380   3              case 1:
 381   3                  CloudSendDataIdx = sprintf(CloudSendData, "\"Error\":%bu",DS18B20ST.TemperatureLow);
 382   3                  break;
 383   3              case 2:
 384   3                  CloudSendDataIdx = sprintf(CloudSendData, "\"Error\":%bu",DS18B20ST.TemperatureHigh);
 385   3                  break;
 386   3              }
 387   2          }
 388   1          CloudAct.Cmd = AT_MQTTSEND; //已写入设备待上报属性,准备发布
 389   1          CloudSend(0);
 390   1          return 0;
 391   1      }
 392          static void CloudHandleReceive(void)
 393          {
 394   1      #if LOGRANK_UART1 >= 3
 395   1          printf("LOG:HandleReceive$%s\r\n", CloudReceiveBuffer);
 396   1      #endif
 397   1          if (strncmp(CloudReceiveBuffer, "ERROR", 5) == 0) //命令执行异常
 398   1          {
 399   2              //目前不处理,待完善
 400   2          }
 401   1          else if (strncmp(CloudReceiveBuffer, "OK", 2) == 0) //命令执行正常
 402   1          {
 403   2              if (CloudAct.Cmd != AT_MQTTSTART && CloudAct.Cmd != AT_MQTTSEND && CloudAct.Cmd != AT_MQTTSUB && C
             -loudAct.Cmd != AT_WJAP)
 404   2              {
 405   3                  CloudAct.NeedAns = false;
 406   3                  if (CloudAct.Cmd == AT_MQTTPUB)
 407   3                      CloudAct.PubCode = CloudAct.PubCode_t; //切换Pub完毕
 408   3              }
 409   2          }
 410   1          else if (CloudReceiveBuffer[0] == '+') //读取详细信息
 411   1          {
 412   2              if (strncmp(CloudReceiveBuffer + 1, "MQTTRECV", 8) == 0) //收到订阅信息
 413   2              {
C51 COMPILER V9.59.0.0   CLOUDHANDLE                                                       04/13/2020 15:54:55 PAGE 8   

 414   3                  switch (CloudReceiveBuffer[10]) //判断订阅的通道
 415   3                  {
 416   4                  case '0': //属性设置通道
 417   4                      break;
 418   4                  case '1': //设备服务调用
 419   4                      break;
 420   4                  case '3': //云端响应属性上报
 421   4                      break;
 422   4                  case '4': //云端响应事件上报
 423   4                      break;
 424   4                  }
 425   3              }
 426   2              else if (strncmp(CloudReceiveBuffer + 1, "MQTTEVENT", 9) == 0)
 427   2              {
 428   3                  if (CloudAct.Cmd == AT_MQTTSTART && (strncmp(CloudReceiveBuffer + 11, "CONNECT", 7) == 0))
 429   3                      if (strncmp(CloudReceiveBuffer + 19, "SUCCESS", 7) == 0)
 430   3                          CloudAct.NeedAns = false; //成功连接
 431   3                  if (CloudAct.Cmd == AT_MQTTSUB && (strncmp(CloudReceiveBuffer + 11, "SUBSCRIBE", 9) == 0))
 432   3                      if (strncmp(CloudReceiveBuffer + 21, "SUCCESS", 7) == 0)
 433   3                          CloudAct.NeedAns = false; //成功设置订阅
 434   3                  if (CloudAct.Cmd == AT_MQTTSEND && (strncmp(CloudReceiveBuffer + 11, "PUBLISH", 7) == 0))
 435   3                      if (strncmp(CloudReceiveBuffer + 19, "SUCCESS", 7) == 0)
 436   3                          CloudAct.NeedAns = false; //成功发布
 437   3              }
 438   2              else if (strncmp(CloudReceiveBuffer + 1, "WEVENT", 6) == 0)
 439   2              {
 440   3                  if (CloudAct.Cmd == AT_WJAP && (strncmp(CloudReceiveBuffer + 8, "STATION_UP", 10) == 0))
 441   3                      CloudAct.NeedAns = false; //成功连接
 442   3              }
 443   2          }
 444   1          else //读取附加信息
 445   1          {
 446   2              //目前用不到
 447   2          }
 448   1      }
 449          //------------------------------------------------------------------------------------------------//


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2405    ----
   CONSTANT SIZE    =    785    ----
   XDATA SIZE       =   1124       8
   PDATA SIZE       =   ----       1
   DATA SIZE        =      1       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
