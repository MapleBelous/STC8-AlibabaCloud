C51 COMPILER V9.59.0.0   DS18B20                                                           04/13/2020 21:24:44 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN .\Objects\DS18B20.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\Sensor\DS18B20\DS18B20.c OMF2 OPTIMIZE(9,SPEED) BROWSE MODP2 INCDIR
                    -(.\Code\Basic\def;.\Code\Basic\delay;.\Code\Basic\init;.\Code\Basic\uart;.\Code\Sensor\DS18B20;.\Code\Sensor\LCD1602;.\C
                    -ode\AlibabaCloud) DEBUG PRINT(.\Listings\DS18B20.lst) OBJECT(.\Objects\DS18B20.obj)

line level    source

   1          #include "DS18B20.h"
   2          //------------------------------------------------------------------------------------------------//
   3          xdata DS18B20ActST DS18B20ST;
   4          code ushort DS18B20ConvertTMaxTime[4] = {95, 190, 378, 753};       //温度转换最大等待时间(ms)
   5          code float DS18B20ReTransfrom[4] = {0.5F, 0.25F, 0.125F, 0.0625F}; //恢复Float值所需系数
   6          //------------------------------------------------------------------------------------------------//
   7          static bool DS18B20Init(void);            //初始化程序
   8          static void DS18B20WriteByte(uchar Byte); //写入一个字节数据
   9          static uchar DS18B20ReadByte(void);       //读取一个字节数据
  10          //------------------------------------------------------------------------------------------------//
  11          void DS18B20STInit(void) //初始化DS18B20内存&读取当前DS18B20分辨率
  12          {
  13   1          uchar Temp, TH, TL;
  14   1          memset(&DS18B20ST, 0, sizeof(DS18B20ActST)); //初始化后的缓存温度值应为DS18B20MinT
  15   1          if (DS18B20Init() == EXIT_FAILURE)           //DS18B20初始化失败
  16   1          {
  17   2      #if LOGRANK_UART1 >= 1
  18   2              printf("ERR:DS18B20Init fail when DS18B20STInit!\r\n");
  19   2      #endif
  20   2              return; //放弃读取DS18B20分辨率.并日志记录ERR信息
  21   2          }
  22   1          DS18B20WriteByte(DS18B20SkipROM);                   //写入跳过ROM操作
  23   1          DS18B20WriteByte(DS18B20ReadRAM);                   //写入读取RAM指令
  24   1          Temp = DS18B20ReadByte(), Temp = DS18B20ReadByte(); //跳过温度,此时不能趁机读取温度,是无效值
  25   1          TH = DS18B20ReadByte(), TL = DS18B20ReadByte();     //跳过TH/TL
  26   1          Temp = DS18B20ReadByte();                           //读取配置寄存器
  27   1          DS18B20ST.ResolutionMode = (Temp >> 5) & 0x03;      //存入DS18B20任务指示器中
  28   1          DS18B20ST.TemperatureHighData1 = TemperatureH;      //确定当前Mode下高温报警阈值
  29   1          DS18B20ST.TemperatureHighData2 = DS18B20ST.TemperatureHighData1 - TemperatureT;
  30   1          DS18B20ST.TemperatureLowData1 = TemperatureL; //确定当前Mode下低温报警阈值
  31   1          DS18B20ST.TemperatureLowData2 = DS18B20ST.TemperatureLowData1 + TemperatureT;
  32   1          DS18B20ConvertTemperature();      //初始化-开始转换温度#忽略返回值
  33   1          switch (DS18B20ST.ResolutionMode) //对应Mode延时
  34   1          {
  35   2          case 0:
  36   2              delay_ms(100);
  37   2              break;
  38   2          case 1:
  39   2              delay_ms(200);
  40   2              break;
  41   2          case 2:
  42   2              delay_ms(385);
  43   2              break;
  44   2          case 3:
  45   2              delay_ms(765);
  46   2              break;
  47   2          }
  48   1          DS18B20GetTemperature(); //初始化-读取温度值#忽略返回值
  49   1      #if LOGRANK_UART1 >= 2
  50   1          printf("LOG#:DS18B20Init ok\r\n");
  51   1      #endif
  52   1      #if LOGRANK_UART1 >= 3
  53   1          printf("LOG:TH-%bu,TL-%bu,Mode-%bu,H1-%u,H2-%u,L1-%u,L2-%u\r\n",
C51 COMPILER V9.59.0.0   DS18B20                                                           04/13/2020 21:24:44 PAGE 2   

  54   1                 TH, TL, DS18B20ST.ResolutionMode,
  55   1                 DS18B20ST.TemperatureHighData1, DS18B20ST.TemperatureHighData2,
  56   1                 DS18B20ST.TemperatureLowData1, DS18B20ST.TemperatureLowData2);
  57   1      #endif
  58   1      }
  59          bool DS18B20Set(char TH, char TL, uchar Mode) //设置并保存TH/TL/Mode
  60          {
  61   1          if (DS18B20Init() == EXIT_FAILURE) //DS18B20初始化失败,返回错误码EXIT_FAILURE
  62   1              return EXIT_FAILURE;
  63   1          DS18B20WriteByte(DS18B20SkipROM);  //写入跳过ROM操作
  64   1          DS18B20WriteByte(DS18B20WriteRAM); //写入写入RAM指令
  65   1          DS18B20WriteByte(TH);
  66   1          DS18B20WriteByte(TL);
  67   1          DS18B20WriteByte(Mode << 5);
  68   1          if (DS18B20Init() == EXIT_FAILURE) //DS18B20初始化失败,返回错误码EXIT_FAILURE
  69   1              return EXIT_FAILURE;
  70   1          DS18B20WriteByte(DS18B20SkipROM); //写入跳过ROM操作
  71   1          DS18B20WriteByte(DS18B20CopyRAM); //写入保存RAM到E2CROM
  72   1          return EXIT_SUCCESS;
  73   1      }
  74          bool DS18B20ConvertTemperature(void) //开始转换温度值
  75          {
  76   1          if (DS18B20Init() == EXIT_FAILURE) //DS18B20初始化失败,返回错误码EXIT_FAILURE
  77   1              return EXIT_FAILURE;
  78   1          DS18B20WriteByte(DS18B20SkipROM);  //写入跳过ROM操作
  79   1          DS18B20WriteByte(DS18B20ConvertT); //写入开始转换温度指令
  80   1          return EXIT_SUCCESS;
  81   1      }
  82          bool DS18B20GetTemperature(void) //读取温度值
  83          {
  84   1          pdata uchar H, L;
  85   1          pdata ushort T, Base = DS18B20MinT;
  86   1          Base = -Base, Base <<= (1 + DS18B20ST.ResolutionMode); //Gizwit传输基准值
  87   1          if (DS18B20Init() == EXIT_FAILURE)                     //DS18B20初始化失败,返回错误码DS18B20InitFail
  88   1              return EXIT_FAILURE;
  89   1          DS18B20WriteByte(DS18B20SkipROM);             //写入跳过ROM操作
  90   1          DS18B20WriteByte(DS18B20ReadRAM);             //写入读取RAM指令
  91   1          L = DS18B20ReadByte(), H = DS18B20ReadByte(); //读取温度寄存器
  92   1          T = H, T <<= 8, T |= L;                       //合并读取到的温度
  93   1          T >>= (3 - (DS18B20ST.ResolutionMode));       //修正为当前分辨率
  94   1          if ((T & 0x1000) && (T & 0x0800))             //温度值为负数,以两个符号位确定
  95   1          {
  96   2              T = ~T, ++T;  //取原码
  97   2              T = Base - T; //以基准值计算最终无符号类型温度值
  98   2          }
  99   1          else
 100   1              T += Base; //以基准值计算最终无符号类型温度值
 101   1          if (T != DS18B20ST.TemperatureData)
 102   1          {
 103   2              DS18B20ST.TemperatureData = T; //更新温度数据
 104   2              CloudAct.NeedReport = true;    //与历史温度值不同,立即挂起设备上报任务
 105   2              if (DS18B20ST.TemperatureLow == false && T <= (DS18B20ST.TemperatureLowData1))
 106   2                  DS18B20ST.TemperatureLow = true, CloudAct.NeedReport_WaterTemperatureLow = true; //低温报警
 107   2              if (DS18B20ST.TemperatureLow == true && T >= (DS18B20ST.TemperatureLowData2))
 108   2                  DS18B20ST.TemperatureLow = false, CloudAct.NeedReport_WaterTemperatureLow = true; //低温报警取
             -消
 109   2              if (DS18B20ST.TemperatureHigh == false && T >= (DS18B20ST.TemperatureHighData1))
 110   2                  DS18B20ST.TemperatureHigh = true, CloudAct.NeedReport_WaterTemperatureHigh = true; //高温报警
 111   2              if (DS18B20ST.TemperatureHigh == true && T <= (DS18B20ST.TemperatureHighData2))
 112   2                  DS18B20ST.TemperatureHigh = false, CloudAct.NeedReport_WaterTemperatureHigh = true; //高温报警
             -取消
 113   2          }
C51 COMPILER V9.59.0.0   DS18B20                                                           04/13/2020 21:24:44 PAGE 3   

 114   1          return EXIT_SUCCESS;
 115   1      }
 116          //------------------------------------------------------------------------------------------------//
 117          static bool DS18B20Init(void) //初始化程序
 118          {
 119   1          pdata uchar i = 20;
 120   1          DS18B20_DATA = 1, delay_us(60), DS18B20_DATA = 0;
 121   1          delay_us(485), DS18B20_DATA = 1; //延时等待后上拉总线
 122   1          do
 123   1          {
 124   2              delay_us(10);
 125   2          } while (DS18B20_DATA == 1 && (--i)); //等待DS18B20应答
 126   1          if (i == 0)
 127   1          {
 128   2      #if LOGRANK_UART1 >= 1
 129   2              printf("ERR:DS18B20Init fail\r\n"); //日志记录DS18B20初始化未收到应答
 130   2      #endif
 131   2              return EXIT_FAILURE;
 132   2          }
 133   1          DS18B20_DATA = 1; //发送已经就位
 134   1          delay_us(130);    //等待DS18B20就位,实测150以上绝对稳定
 135   1          return EXIT_SUCCESS;
 136   1      }
 137          static void DS18B20WriteByte(uchar Byte) //写入一个字节数据
 138          {
 139   1          pdata uchar i;
 140   1          for (i = 0; i != 8; ++i, Byte >>= 1)
 141   1          {
 142   2              DS18B20_DATA = 0;
 143   2              delay_us(1);
 144   2              DS18B20_DATA = Byte & 0x01;
 145   2              delay_us(60);
 146   2              DS18B20_DATA = 1;
 147   2              delay_us(1);
 148   2          }
 149   1      }
 150          static uchar DS18B20ReadByte(void) //读取一个字节数据
 151          {
 152   1          pdata uchar i, re;
 153   1          DS18B20_DATA = 1;
 154   1          delay_us(10);
 155   1          for (i = 0, re = 0; i != 8; ++i)
 156   1          {
 157   2              re >>= 1;
 158   2              DS18B20_DATA = 0;
 159   2              delay_us(1);
 160   2              DS18B20_DATA = 1;
 161   2              delay_us(1);
 162   2              if (DS18B20_DATA == 1)
 163   2                  re |= 0x80;
 164   2              delay_us(60);
 165   2          }
 166   1          return re;
 167   1      }
 168          //------------------------------------------------------------------------------------------------//


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    944    ----
   CONSTANT SIZE    =    165    ----
   XDATA SIZE       =     11    ----
   PDATA SIZE       =   ----      10
C51 COMPILER V9.59.0.0   DS18B20                                                           04/13/2020 21:24:44 PAGE 4   

   DATA SIZE        =   ----       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
